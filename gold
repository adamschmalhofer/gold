#!/usr/bin/python
"""
A reward system that complements taskwarrior.

In order for this to work, you need this in your ~/.taskrc:
    uda.bounty.label=Bounty
    uda.bounty.type=numeric

Then assign bounties to some tasks:
    task +university modify bounty:10

When you complete tasks with a bounty and run `gold`, it will count the gold
you gained since you last ran it and add it to your account (~/.gold).

You can use the gold to buy rewards with `gold <rewardname>`

Format of ~/.gold_rewards.csv: NAME[string],COST[int]

Add tab completions to bash with this line: (breaks on spaces in reward names!)
    complete -W "$(gold --list-raw)" gold
"""

import time
from argparse import ArgumentParser
import sys
import os.path
import csv
from os.path import expanduser
from subprocess import (getoutput, call)
from collection import namedtuple

# CONSTANTS
EDITOR = os.environ.get("EDITOR", "vim")
COMPETTION_MSG = "\033[0;38;5;46m+{bounty} gold for completing `{name}`\033[0m"


# LIB


BountySet = namedtuple('bounties', 'gold')
Task = namedtuple('uuid', 'bounty', 'decription')
RewardItem = namedtuple('name', 'cost')


class TaskWarriorStore(object):
    QUERY_GETALL = "rc.context= status:completed bounty.any: _uuids"
    QUERY_GETATTR = "_get {uuid}.{attr}"

    def _task(self, query, *args, **kwds):
        return getoutput("task " + query.format(*args, **kwds))

    def _attr(self, uuid, attr):
        return self._task(self.QUERY_GETATTR, uuid=uuid, attr=attr)

    def get_completed_tasks_with_bounty(self):
        return set(self._task(self.QUERY_GETALL).split("\n"))

    def get_task_bounty(self, uuid):
        return int(self._attr(uuid, "bounty"))

    def get_task_description(self, uuid):
        return self._attr(uuid, "description")


class DotGoldStore(object):
    FNAME_COLLECTED = expanduser("~/.gold_collected")
    FNAME_GOLD = expanduser("~/.gold")
    FNAME_REWARDS = expanduser("~/.gold_rewards.csv")
    FNAME_REWARDHISTORY = expanduser("~/.gold_history.csv")

    def __init__(self, task_store):
        self.task_store = task_store

    def _get_task(self, task_uuid):
        bounty = self.task_store.get_task_bounty(task_uuid)
        description = self.task_store.get_task_description(task_uuid)
        return Task(task_uuid, bounty, description)

    def update_gold_budget(self, calculate_new_gold_budget):
        previous_state = self.task_store.get_collected_tasks()
        collected = self.task_store.get_completed_tasks_with_bounty()
        current_uuids = previous_state.bounties
        new_uuids = current_uuids - collected.have_uuids
        tasks = [self._get_task(t) for t in new_uuids]
        gold = calculate_new_gold_budget(previous_state, tasks)
        self.save_current_state(BountySet(current_uuids | collected.have_uuids,
                                gold))

    def _read_rewards(self):
        try:
            f = open(self.FNAME_REWARDS, "r")
        except FileNotFoundError:
            return CsvRewardSnapshot(dict())
        else:
            result = dict((entry[0], dict(name=entry[0], cost=entry[1]))
                          for entry in csv.reader(f))
            f.close()
            return CsvRewardSnapshot(result)

    def print_rewards(self, raw=False):
        rewards = self._read_rewards()
        if raw:
            rewards.print_raw()
        else:
            rewards.print_pretty()

    def maybe_get_reward_by_id(self, reward_id):
        return self._read_rewards().maybe_get_by_id(reward_id)

    def reset(self):
        os.unlink(self.FNAME_COLLECTED)
        os.unlink(self.FNAME_GOLD)

    def edit_rewards(self):
        call([EDITOR, self.FNAME_REWARDS])

    def edit_history(self):
        call([EDITOR, self.FNAME_REWARDHISTORY])

    def get_collected_tasks(self):
        # DATA COLLECTION
        try:
            have_uuids = set(open(self.FNAME_COLLECTED, "r"
                                  ).read().rstrip().split("\n"))
        except FileNotFoundError:
            have_uuids = set()
        try:
            gold = int(open(self.FNAME_GOLD, "r").read())
        except FileNotFoundError:
            gold = 0
        return BountySet(have_uuids, gold)

    def buy_reward(self, reward):
        fmt = "{date},{name},{cost}\n"
        open(self.FNAME_REWARDHISTORY, "a"
             ).write(fmt.format(date=time.strftime("%x %X"), **reward))

    def save_current_state(self, collected):
        open(self.FNAME_COLLECTED, "w").write("\n".join(collected.bounties))
        open(self.FNAME_GOLD, "w").write(str(collected.gold) + "\n")


class CsvRewardSnapshot(object):
    def __init__(self, dic):
        self.dic = dic

    def maybe_get_by_id(self, reward_id):
        return (self.to_RewardItem(self.dic[opt.reward])
                if opt.reward in self.dic
                else None)

    def to_RewardItem(self, thing):
        cost = int(thing['cost'])
        return RewardItem(thing['name'], cost)

    def print_pretty(self):
        try:
            items = list(self.dic.items())
        except FileNotFoundError:
            pass
        else:
            fmt = "\033[0;38;5;132m{cost:>4} gold: {name}\033[0m"
            items.sort(key=lambda item: item[0])
            items.sort(key=lambda item: int(item[1]['cost']))
            lines = map((lambda item: fmt.format(**item[1])), items)
            for line in lines:
                print(line)

    def print_raw(self):
        for reward in self.dic():
            print(reward)


def get_on_completion_message(task):
    COMPETTION_MSG.format(bounty=task.bounty, name=task.description)


# ARGUMENTS
ap = ArgumentParser(description=__doc__.split("\n")[1])
ap.add_argument("--reset", action="store_true",
                help="remove the ~/.gold and ~/.gold_collected files")
ap.add_argument("--force", "-f", action="store_true",
                help="buy it even if it means going below 0 gold")
ap.add_argument("--edit", "-e", action="store_true",
                help="edit the rewards")
ap.add_argument("--history", action="store_true",
                help="edit the transaction history")
ap.add_argument("reward", type=str, nargs='?',
                help="specify any string as argument to buy that reward")
ap.add_argument("--list-raw", action="store_true",
                help="list the reward names, for tab completion scripts")
opt = ap.parse_args()

store = DotGoldStore(TaskWarriorStore())

if opt.reset:
    print("resetting gold...")
    store.reset()
    sys.exit()
if opt.edit:
    store.edit_rewards()
    sys.exit()
if opt.history:
    store.edit_history()
    sys.exit()
if opt.list_raw:
    store.print_rewards(raw=True)
    sys.exit()


# LOGIC
if not opt.reward:
    store.print_rewards()


def calculate_new_gold_budget(previous_state, newly_completed_tasks):
    gold = sum(task.bounty for task in previous_state)
    print('\n'.join(get_on_completion_message(task)
                    for task in newly_completed_tasks))
    if opt.reward:
        reward = store.maybe_get_reward_by_id(opt.reward)
        if reward is not None:
            if gold < reward.cost and not opt.force:
                print("Not enough money for {name}!".format(reward.name))
            else:
                gold -= reward.cost
                print("Bought {name} for {cost}!".format(**reward))
                # Record the transaction
                store.buy_reward(reward)
        else:
            print("No such reward: {name}!".format(name=opt.reward))
    print("\033[1;38;5;214mGold: %d\033[0m" % gold)
    return gold


store.update_gold_budget(calculate_new_gold_budget)
