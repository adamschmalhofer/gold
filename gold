#!/usr/bin/python
"""
A reward system that complements taskwarrior.

In order for this to work, you need this in your ~/.taskrc:
    uda.bounty.label=Bounty
    uda.bounty.type=numeric

Then assign bounties to some tasks:
    task +university modify bounty:10

When you complete tasks with a bounty and run `gold`, it will count the gold
you gained since you last ran it and add it to your account (~/.gold).

You can use the gold to buy rewards with `gold <rewardname>`

Format of ~/.gold_rewards.csv: NAME[string],COST[int]

Add tab completions to bash with this line: (breaks on spaces in reward names!)
    complete -W "$(gold --list-raw)" gold
"""

import time
from argparse import ArgumentParser
import sys
import os.path
import csv
from os.path import expanduser
from subprocess import (getoutput, call)

# CONSTANTS
EDITOR = os.environ.get("EDITOR", "vim")
COMPETTION_MSG = "\033[0;38;5;46m+{bounty} gold for completing `{name}`\033[0m"


# LIB


class TaskWarriorStore(object):
    QUERY_GETALL = "rc.context= status:completed bounty.any: _uuids"
    QUERY_GETATTR = "_get {uuid}.{attr}"

    def _task(self, query, *args, **kwds):
        return getoutput("task " + query.format(*args, **kwds))

    def _attr(self, uuid, attr):
        return self._task(self.QUERY_GETATTR, uuid=uuid, attr=attr)

    def get_current_uids(self):
        return set(self._task(self.QUERY_GETALL).split("\n"))

    def get_task_bounty(self, uuid):
        return int(self._attr(uuid, "bounty"))

    def get_task_description(self, uuid):
        return self._attr(uuid, "description")


class DotGoldStore(object):
    FNAME_COLLECTED = expanduser("~/.gold_collected")
    FNAME_GOLD = expanduser("~/.gold")
    FNAME_REWARDS = expanduser("~/.gold_rewards.csv")
    FNAME_REWARDHISTORY = expanduser("~/.gold_history.csv")

    def __init__(self, task_store):
        self.task_store = task_store

    def get_current_uids(self):
        return self.task_store.get_current_uids()

    def get_task(self, task_uuid):
        bounty = self.task_store.get_task_bounty(uuid)
        description = self.task_store.get_task_description(uuid)
        return Task(task_uuid, bounty, description)

    def _read_rewards(self):
        try:
            f = open(self.FNAME_REWARDS, "r")
        except FileNotFoundError:
            return CsvRewardSnapshot(dict())
        else:
            result = dict((entry[0], dict(name=entry[0], cost=entry[1]))
                          for entry in csv.reader(f))
            f.close()
            return CsvRewardSnapshot(result)

    def print_rewards(self, raw=False):
        rewards = self._read_rewards()
        if raw:
            rewards.print_raw()
        else:
            rewards.print_pretty()

    def maybe_get_reward_by_id(self, reward_id):
        return self._read_rewards().maybe_get_by_id(reward_id)

    def reset(self):
        os.unlink(self.FNAME_COLLECTED)
        os.unlink(self.FNAME_GOLD)

    def edit_rewards(self):
        call([EDITOR, self.FNAME_REWARDS])

    def edit_history(self):
        call([EDITOR, self.FNAME_REWARDHISTORY])

    def get_collected(self):
        # DATA COLLECTION
        try:
            have_uuids = set(open(self.FNAME_COLLECTED, "r"
                                  ).read().rstrip().split("\n"))
        except FileNotFoundError:
            have_uuids = set()
        try:
            gold = int(open(self.FNAME_GOLD, "r").read())
        except FileNotFoundError:
            gold = 0
        return BountySet(have_uuids, gold)

    def buy_reward(self, reward):
        fmt = "{date},{name},{cost}\n"
        open(self.FNAME_REWARDHISTORY, "a"
             ).write(fmt.format(date=time.strftime("%x %X"), **reward))

    def save_current_state(self, collected):
        open(self.FNAME_COLLECTED, "w").write("\n".join(collected.bounties))
        open(self.FNAME_GOLD, "w").write(str(collected.gold) + "\n")


class BountySet(object):
    def __init__(self, bounties, gold):
        self.bounties = bounties
        self.gold = gold


class Task(object):
    def __init__(self, uuid, bounty, description):
        self.uuid = uuid
        self.bounty = bounty
        self.description = description

    def get_on_completion_message(self):
        self.COMPETTION_MSG.format(bounty=self.bounty, name=self.description)


class RewardItem(object):
    def __init__(self, name, cost):
        self.name = name
        self.cost = cost


class CsvRewardSnapshot(object):
    def __init__(self, dic):
        self.dic = dic

    def maybe_get_by_id(self, reward_id):
        return (self.to_RewardItem(self.dic[opt.reward])
                if opt.reward in self.dic
                else None)

    def to_RewardItem(self, thing):
        cost = int(thing['cost'])
        return RewardItem(thing['name'], cost)

    def print_pretty(self):
        try:
            items = list(self.dic.items())
        except FileNotFoundError:
            pass
        else:
            fmt = "\033[0;38;5;132m{cost:>4} gold: {name}\033[0m"
            items.sort(key=lambda item: item[0])
            items.sort(key=lambda item: int(item[1]['cost']))
            lines = map((lambda item: fmt.format(**item[1])), items)
            for line in lines:
                print(line)

    def print_raw(self):
        for reward in self.dic():
            print(reward)


store = DotGoldStore(TaskWarriorStore())
# ARGUMENTS
ap = ArgumentParser(description=__doc__.split("\n")[1])
ap.add_argument("--reset", action="store_true",
                help="remove the ~/.gold and ~/.gold_collected files")
ap.add_argument("--force", "-f", action="store_true",
                help="buy it even if it means going below 0 gold")
ap.add_argument("--edit", "-e", action="store_true",
                help="edit the rewards")
ap.add_argument("--history", action="store_true",
                help="edit the transaction history")
ap.add_argument("reward", type=str, nargs='?',
                help="specify any string as argument to buy that reward")
ap.add_argument("--list-raw", action="store_true",
                help="list the reward names, for tab completion scripts")
opt = ap.parse_args()

if opt.reset:
    print("resetting gold...")
    store.reset()
    sys.exit()
if opt.edit:
    store.edit_rewards()
    sys.exit()
if opt.history:
    store.edit_history()
    sys.exit()
if opt.list_raw:
    store.print_rewards(raw=True)
    sys.exit()

collected = store.get_collected()
current_uuids = store.get_current_uids()

# LOGIC
if not opt.reward:
    store.print_rewards()

new_uuids = current_uuids - collected.have_uuids
gold = collected.gold
for uuid in new_uuids:
    task = store.get_task(uuid)
    print(task.get_on_completion_message())
    gold += task.bounty

if opt.reward:
    reward = store.maybe_get_reward_by_id(opt.reward)
    if reward is not None:
        if gold < reward.cost and not opt.force:
            print("Not enough money for {name}!".format(reward.name))
        else:
            gold -= reward.cost
            print("Bought {name} for {cost}!".format(**reward))
            # Record the transaction
            store.buy_reward(reward)
    else:
        print("No such reward: {name}!".format(name=opt.reward))

print("\033[1;38;5;214mGold: %d\033[0m" % gold)

# DATA STORAGE
store.save_current_state(BountySet(current_uuids | collected.have_uuids, gold))
